#------------------------------------------------------------------------------
# Embedded Utilities
#------------------------------------------------------------------------------
cmake_minimum_required(VERSION 3.25.0)
cmake_policy(VERSION 3.25)

#------------------------------------------------------------------------------
# Constants
#------------------------------------------------------------------------------
set(EMBEDDED_DEPS_REGEX "_deps")
set(EMBEDDED_GENERATOR_EXPR_REGEX "^\\$<")

#------------------------------------------------------------------------------
# Function: add_elf2bin_dependency
# Adds functionality to create ${target}.bin from ${target}.elf
#
# INTERFACE:
#   target
#       Base name of the ELF target (without .elf extension)
#
# REQUIREMENTS:
#   Requires CMAKE_OBJCOPY to be available in the build environment
#------------------------------------------------------------------------------
function(add_elf2bin_dependency target)
  if(NOT target)
    message(FATAL_ERROR "add_elf2bin_dependency: target parameter is required")
  endif()

  if(NOT CMAKE_OBJCOPY)
    message(FATAL_ERROR "add_elf2bin_dependency: CMAKE_OBJCOPY is not set")
  endif()

  add_custom_target(${target}.bin EXCLUDE_FROM_ALL DEPENDS ${target}.elf)
  add_custom_command(TARGET ${target}.bin
    COMMAND ${CMAKE_OBJCOPY} ARGS -O binary ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/${target}.elf ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/${target}.bin)
endfunction()

#------------------------------------------------------------------------------
# Function: add_bin2lst_dependency
# Adds functionality to create ${target}.lst from ${target}.bin
#
# INTERFACE:
#   target
#       Base name of the binary target (without .bin extension)
#
# REQUIREMENTS:
#   Requires CMAKE_OBJDUMP to be available in the build environment
#------------------------------------------------------------------------------
function(add_bin2lst_dependency target)
  if(NOT target)
    message(FATAL_ERROR "add_bin2lst_dependency: target parameter is required")
  endif()

  if(NOT CMAKE_OBJDUMP)
    message(FATAL_ERROR "add_bin2lst_dependency: CMAKE_OBJDUMP is not set")
  endif()

  add_custom_target(${target}.lst EXCLUDE_FROM_ALL DEPENDS ${target}.bin)
  add_custom_command(TARGET ${target}.lst
    COMMAND ${CMAKE_OBJDUMP} ARGS -D -b binary -marm ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/${target}.bin > ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/${target}.lst)
endfunction()


#------------------------------------------------------------------------------
# Function: add_target_variants
#
# Creates multiple build variants of a target. The generator function must accept
# a single argument that specifies the build type variant suffix. Useful for
# targets that want to always build with specific configurations.
#
# INTERFACE:
#   target_generator_func
#       Function name that will be called with different variant suffixes:
#       - "" (empty): Uses CMAKE_BUILD_TYPE for configuration
#       - "_rel": Always uses release configuration
#       - "_rel_dbg": Always uses release-with-debug configuration
#       - "_dbg": Always uses debug configuration
#
# REQUIREMENTS:
#   The generator function must properly handle the variant suffix parameter.
#------------------------------------------------------------------------------
function(add_target_variants target_generator_func)
  if(NOT target_generator_func)
    message(FATAL_ERROR "add_target_variants: target_generator_func parameter is required")
  endif()

  cmake_language(CALL ${target_generator_func} "")       # This build varies with CMAKE_BUILD_TYPE
  cmake_language(CALL ${target_generator_func} _rel)     # Always project's settings for release build
  cmake_language(CALL ${target_generator_func} _rel_dbg) # Always project's settings for release with debug options
  cmake_language(CALL ${target_generator_func} _dbg)     # Always project's settings for debug build
endfunction()


#------------------------------------------------------------------------------
# FUNCTION: gen_intf_lib
#
#   Generates an interface library. Originally created to allow larger projects
#   to expose a target that includes all definitions and header file paths
#   needed for a consuming project to integrate with. This way it's a bit
#   easier to manage the dependencies of a project.
#
# INTERFACE:
#   TARGET
#       This is the name you want to reference the generated library by
#
#   INTF_INCLUDES
#       Include paths needed to integrate with the module
#
#   INTF_DEFINES
#       Preprocessor definitions needed to compile the module
#
#   INTF_LIBRARIES
#       A list of all library targets to link against
#
#   EXPORT_DIR
#       Root directory of where to place the resulting generated <xyz>.cmake
#       files. This is so other targets in the project can actually reference
#       the targets generated by this function.
#
#------------------------------------------------------------------------------
function(gen_intf_lib)
  #----------------------------------------------------------
  # Parse the input arguments
  #----------------------------------------------------------
  set(options "")
  set(oneValueArgs TARGET EXPORT_DIR)
  set(multiValueArgs INTF_INCLUDES INTF_DEFINES INTF_LIBRARIES)
  cmake_parse_arguments(GEN_INTF_LIB "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})

  #----------------------------------------------------------
  # Validate required parameters
  #----------------------------------------------------------
  if(NOT GEN_INTF_LIB_TARGET)
    message(FATAL_ERROR "gen_intf_lib: TARGET parameter is required")
  endif()

  if(NOT GEN_INTF_LIB_EXPORT_DIR)
    message(FATAL_ERROR "gen_intf_lib: EXPORT_DIR parameter is required")
  endif()

  #----------------------------------------------------------
  # Build the library
  #----------------------------------------------------------
  add_library(${GEN_INTF_LIB_TARGET} INTERFACE EXCLUDE_FROM_ALL)

  if(GEN_INTF_LIB_INTF_INCLUDES)
    target_include_directories(${GEN_INTF_LIB_TARGET} INTERFACE ${GEN_INTF_LIB_INTF_INCLUDES})
  endif()

  if(GEN_INTF_LIB_INTF_DEFINES)
    target_compile_definitions(${GEN_INTF_LIB_TARGET} INTERFACE ${GEN_INTF_LIB_INTF_DEFINES})
  endif()

  if(GEN_INTF_LIB_INTF_LIBRARIES)
    target_link_libraries(${GEN_INTF_LIB_TARGET} INTERFACE ${GEN_INTF_LIB_INTF_LIBRARIES})
  endif()

  # Export so other targets can use this (skip if target depends on non-exportable dependencies)
  export_target_safely(${GEN_INTF_LIB_TARGET} "${GEN_INTF_LIB_EXPORT_DIR}/${GEN_INTF_LIB_TARGET}.cmake")
endfunction()


#------------------------------------------------------------------------------
# FUNCTION: gen_static_lib_variants
#
#   Creates a static library for a set of source files. Additionally generates
#   named build variants of each lib to allow project to easily select what it
#   needs.
#
# INTERFACE:
#   TARGET
#       This is simply the name you want to reference the generated static
#       library target by.
#
#   SOURCES
#       Source files to be compiled into the library
#
#   DEPENDENCIES
#       Targets this static library depends on
#
#   PUB_INCLUDES
#       Public includes that should be propagated to all dependents
#
#   PUB_DEFINES
#       Public preprocessor definitions that are propagated to all dependents
#
#   PUB_LIBRARIES
#       Public libraries that are propagated to all dependents
#
#   PRV_INCLUDES
#       Private include paths needed to build the module.
#
#   PRV_DEFINES
#       Preprocessor definitions needed to compile the module. Flagged as
#       private to prevent propagation to upstream dependencies.
#
#   PRV_LIBRARIES
#       A list of all library targets to link against. This is a great way
#       to inject dependencies on other interface libraries for things like
#       header file include paths, compiler settings, etc. Flagged as private
#       to prevent propagation to upstream dependencies.
#
#   EXPORT_DIR
#       Root directory of where to place the resulting generated <xyz>.cmake
#       files. This is so other targets in the project can actually reference
#       the targets generated by this function.
#
#------------------------------------------------------------------------------
function(gen_static_lib_variants)
  #----------------------------------------------------------
  # Parse the input arguments
  #----------------------------------------------------------
  set(options "")
  set(oneValueArgs TARGET EXPORT_DIR)
  set(multiValueArgs SOURCES PRV_DEFINES PRV_LIBRARIES PRV_INCLUDES PUB_DEFINES PUB_LIBRARIES PUB_INCLUDES DEPENDENCIES)
  cmake_parse_arguments(GEN_STATIC_LIB_VARIANTS "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})

  #----------------------------------------------------------
  # Validate required parameters
  #----------------------------------------------------------
  if(NOT GEN_STATIC_LIB_VARIANTS_TARGET)
    message(FATAL_ERROR "gen_static_lib_variants: TARGET parameter is required")
  endif()

  if(NOT GEN_STATIC_LIB_VARIANTS_SOURCES)
    message(FATAL_ERROR "gen_static_lib_variants: SOURCES parameter is required")
  endif()

  if(NOT GEN_STATIC_LIB_VARIANTS_EXPORT_DIR)
    message(FATAL_ERROR "gen_static_lib_variants: EXPORT_DIR parameter is required")
  endif()

  #----------------------------------------------------------
  # Generator function to build a static library
  #----------------------------------------------------------
  function(build_${GEN_STATIC_LIB_VARIANTS_TARGET} VARIANT)
    #----------------------------------------------------------
    # The name your project should reference
    #----------------------------------------------------------
    set(lib_var_name "${GEN_STATIC_LIB_VARIANTS_TARGET}${VARIANT}")

    #----------------------------------------------------------
    # Create the static library with the desired properties
    #----------------------------------------------------------
    add_library(${lib_var_name} STATIC EXCLUDE_FROM_ALL ${GEN_STATIC_LIB_VARIANTS_SOURCES})

    # Include Paths
    if(GEN_STATIC_LIB_VARIANTS_PRV_INCLUDES)
      target_include_directories(${lib_var_name} PRIVATE ${GEN_STATIC_LIB_VARIANTS_PRV_INCLUDES})
    endif()

    if(GEN_STATIC_LIB_VARIANTS_PUB_INCLUDES)
      target_include_directories(${lib_var_name} PUBLIC ${GEN_STATIC_LIB_VARIANTS_PUB_INCLUDES})
    endif()

    # Compiler preprocessor definitions
    if(GEN_STATIC_LIB_VARIANTS_PRV_DEFINES)
      target_compile_definitions(${lib_var_name} PRIVATE ${GEN_STATIC_LIB_VARIANTS_PRV_DEFINES})
    endif()

    if(GEN_STATIC_LIB_VARIANTS_PUB_DEFINES)
      target_compile_definitions(${lib_var_name} PUBLIC ${GEN_STATIC_LIB_VARIANTS_PUB_DEFINES})
    endif()

    # Link Libraries
    if(GEN_STATIC_LIB_VARIANTS_PRV_LIBRARIES)
      target_link_libraries(${lib_var_name} PRIVATE ${GEN_STATIC_LIB_VARIANTS_PRV_LIBRARIES})
    endif()

    if(GEN_STATIC_LIB_VARIANTS_PUB_LIBRARIES)
      target_link_libraries(${lib_var_name} PUBLIC ${GEN_STATIC_LIB_VARIANTS_PUB_LIBRARIES})
    endif()

    # Dependencies
    if(GEN_STATIC_LIB_VARIANTS_DEPENDENCIES)
      add_dependencies(${lib_var_name} ${GEN_STATIC_LIB_VARIANTS_DEPENDENCIES})
    endif()

    # Always link against these, which defines critical target device compiler options such as the
    # ARM core variant, build flags, FPU support, etc. Every source file in the project MUST be
    # compiled with these in order to build/link properly.
    #
    # See the target device definitions in the CommonTool/cmake/device folders.
    target_link_libraries(${lib_var_name} PRIVATE prj_device_target prj_build_target${VARIANT})

    # Export so other targets can use this (skip if target depends on non-exportable dependencies)
    if(NOT GEN_STATIC_LIB_VARIANTS_EXPORT_DIR)
      message(FATAL_ERROR "Static library generation function requires an EXPORT_DIR entry")
    endif()

    export_target_safely(${lib_var_name} "${GEN_STATIC_LIB_VARIANTS_EXPORT_DIR}/${lib_var_name}.cmake")
  endfunction() # build_${GEN_STATIC_LIB_VARIANTS_TARGET}

  #----------------------------------------------------------
  # Invoke generator function with the desired variant types
  #----------------------------------------------------------
  add_target_variants(build_${GEN_STATIC_LIB_VARIANTS_TARGET})
endfunction() #gen_static_lib_variants


#------------------------------------------------------------------------------
# FUNCTION: gen_intf_lib_variants
#
#   Creates an interface library that is used to collect a group of other libs
#   into a single target for referencing in a project. Additionally generates
#   named build variants of each lib to allow projects to easily select what
#   it needs.
#
# INTERFACE:
#   TARGET
#       This is simply the name you want to reference the generated interface
#       library target by.
#
#   LIBRARIES
#       A list of all library targets in the resulting collection
#
#   EXPORT_DIR
#       Root directory of where to place the resulting generated <xyz>.cmake
#       files. This is so other targets in the project can actually reference
#       the targets generated by this function.
#
# REQUIREMENTS:
#   All libraries in the LIBRARIES argument must have generated named variants as
#   well, or else the function won't know what to reference.
#------------------------------------------------------------------------------
function(gen_intf_lib_variants)
  #----------------------------------------------------------
  # Parse the input arguments
  #----------------------------------------------------------
  set(options "")
  set(oneValueArgs TARGET EXPORT_DIR)
  set(multiValueArgs LIBRARIES)
  cmake_parse_arguments(GEN_INTF_LIB_VARIANTS "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})

  #----------------------------------------------------------
  # Validate required parameters
  #----------------------------------------------------------
  if(NOT GEN_INTF_LIB_VARIANTS_TARGET)
    message(FATAL_ERROR "gen_intf_lib_variants: TARGET parameter is required")
  endif()

  if(NOT GEN_INTF_LIB_VARIANTS_LIBRARIES)
    message(FATAL_ERROR "gen_intf_lib_variants: LIBRARIES parameter is required")
  endif()

  if(NOT GEN_INTF_LIB_VARIANTS_EXPORT_DIR)
    message(FATAL_ERROR "gen_intf_lib_variants: EXPORT_DIR parameter is required")
  endif()

  #----------------------------------------------------------
  # Generator function to build an interface library
  #----------------------------------------------------------
  function(build_${GEN_INTF_LIB_VARIANTS_TARGET} VARIANT)
    #----------------------------------------------------------
    # The name your project should reference
    #----------------------------------------------------------
    set(lib_var_name "${GEN_INTF_LIB_VARIANTS_TARGET}${VARIANT}")

    #----------------------------------------------------------
    # Add the variant flag to each library target
    #----------------------------------------------------------
    set(renamed_libs${VARIANT} "")
    foreach(library ${GEN_INTF_LIB_VARIANTS_LIBRARIES})
      list(APPEND renamed_libs${VARIANT} ${library}${VARIANT})
    endforeach()

    #----------------------------------------------------------
    # Create the interface library with the desired properties
    #----------------------------------------------------------
    add_library(${lib_var_name} INTERFACE EXCLUDE_FROM_ALL)
    target_link_libraries(${lib_var_name} INTERFACE "${renamed_libs${VARIANT}}")
    export_target_safely(${lib_var_name} "${GEN_INTF_LIB_VARIANTS_EXPORT_DIR}/${lib_var_name}.cmake")
  endfunction()

  #----------------------------------------------------------
  # Invoke generator function with the desired variant types
  #----------------------------------------------------------
  add_target_variants(build_${GEN_INTF_LIB_VARIANTS_TARGET})
endfunction() #gen_intf_lib_variants


#------------------------------------------------------------------------------
# FUNCTION: export_target_safely
#
#   Safely exports a target, checking if it depends on non-exportable targets
#   like those from FetchContent (GoogleTest, etc.)
#
# INTERFACE:
#   TARGET_NAME
#       The name of the target to export
#
#   EXPORT_FILE
#       The file to export to
#
#------------------------------------------------------------------------------
function(export_target_safely TARGET_NAME EXPORT_FILE)
  if(NOT TARGET_NAME)
    message(FATAL_ERROR "export_target_safely: TARGET_NAME parameter is required")
  endif()

  if(NOT EXPORT_FILE)
    message(FATAL_ERROR "export_target_safely: EXPORT_FILE parameter is required")
  endif()

  # Check if target exists
  if(NOT TARGET ${TARGET_NAME})
    message(WARNING "Cannot export non-existent target: ${TARGET_NAME}")
    return()
  endif()

  # Get all linked libraries (recursive)
  get_target_property(target_type ${TARGET_NAME} TYPE)
  if(target_type STREQUAL "INTERFACE_LIBRARY")
    get_target_property(linked_libs ${TARGET_NAME} INTERFACE_LINK_LIBRARIES)
  else()
    get_target_property(linked_libs ${TARGET_NAME} LINK_LIBRARIES)
    if(NOT linked_libs)
      get_target_property(linked_libs ${TARGET_NAME} INTERFACE_LINK_LIBRARIES)
    endif()
  endif()

  # Check for non-exportable dependencies
  set(non_exportable_found FALSE)
  if(linked_libs)
    foreach(lib ${linked_libs})
      # Skip keywords and generator expressions
      if(lib MATCHES ${EMBEDDED_GENERATOR_EXPR_REGEX} OR lib MATCHES "^-" OR lib MATCHES "^PRIVATE$" OR lib MATCHES "^INTERFACE$")
        continue()
      endif()

      # Check if this is a target that might not be exportable
      if(TARGET ${lib})
        get_target_property(lib_source ${lib} SOURCE_DIR)
        # If it's from FetchContent/_deps, it's likely not exportable
        if(lib_source AND lib_source MATCHES ${EMBEDDED_DEPS_REGEX})
          set(non_exportable_found TRUE)
          message(STATUS "Target ${TARGET_NAME} depends on non-exportable target ${lib} from FetchContent - skipping export")
          break()
        endif()
      endif()
    endforeach()
  endif()

  # Export if safe to do so
  if(NOT non_exportable_found)
    export(TARGETS ${TARGET_NAME} FILE "${EXPORT_FILE}")
  else()
    message(STATUS "Skipping export of ${TARGET_NAME} due to non-exportable dependencies")
  endif()
endfunction()
